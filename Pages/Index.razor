@page "/"
@inject IJSRuntime JSRuntime
@inject CasheeshContext Context

<div class="m-0">
    <div class="row m-0 w-100 align-items-center">

        <img src="favicon.ico" style="height:64px;" class="col-auto p-0 m-3" />
        <h2 class="col m-0 p-0 text-stroke">Casheesh</h2>
        <div class="col-auto m-3 p-0 button-container button-container-36">
            <input @ref="AccountCreationCheckboxReference" class="invisible-toggle" type="checkbox" id="AccountCreationToggle" />
            <label class="button-label button-label-36 m-0" for="AccountCreationToggle">
                <i class="button-bright position-absolute open-button mdi mdi-pencil mdi-36px icon-responsive-36" @onclick="ToggleEditMode"></i>
                <i class="button-bright position-absolute close-button mdi mdi-close mdi-36px icon-responsive-36" @onclick="ToggleEditMode"></i>
            </label>
        </div>
    </div>

    <div @ref="AccountCreationContainerReference" class="hidden-container d-flex flex-row bd-highlight align-items-center overflow-hidden justify-content-end mb-3 mr-2">
        <i class="button-bright button-label-36 mdi mdi-bank-plus mdi-36px m-0 mr-2"></i>
        <label class="text-stroke m-0 mr-2">Name:</label>
        <input @bind="NewAccountName" class="name-input m-0 mr-2" Name="NewAccountName" />
        <i class="button-bright mdi mdi-content-save icon-responsive m-0" @onclick="CreateAccount"></i>
    </div>

    <div class="d-flex flex-wrap m-0 justify-content-center">
        @foreach (Account account in Context.Accounts.OrderBy(account => account.Order))
        {
            <AccountCard Account="account" @ref="AccountCardReference" AccountChangedCallback="RefreshBalance" AccountOrderChangedCallback="ChangeAccountOrder" IsEditing="IsEditing" />
        }

        <div class="card card-worth-graph bg-dark text-white m-3">
            <div class="d-flex flex-row justify-content-between p-3">
                <div class="d-flex flex-row align-items-center">
                    <i class="button-label mdi mdi-chart-line mr-3"></i>
                    <h4 class="card-title text-stroke m-0">Net Worth by Date</h4>
                </div>
                <h3 class="col card-text text-stroke p-0 text-right @(NetWorth >= 0 ? "color-teal" : NetWorth <= 0 ? "color-red" : string.Empty)">@NetWorth.ToString("C", CultureInfo.GetCultureInfo("en-CA"))</h3>
            </div>
            <div class="p-3 w-100 h-100">
                <Chart @ref="Chart" Config="LineConfig"></Chart>
            </div>            
        </div>
    </div>
</div>

@code
{
    private string NewAccountName { get; set; }
    private bool IsEditing { get; set; } = false;
    private ElementReference AccountCreationCheckboxReference { get; set; }
    private ElementReference AccountCreationContainerReference { get; set; }

    private List<AccountCard> AccountCardReferences = new();
    private AccountCard AccountCardReference { set => AccountCardReferences.Add(value); }

    private double NetWorth = 0;

    private Chart Chart;
    private LineConfig LineConfig;

    private string[] colors =
    {
        "rgb(204,81,81)",
        "rgb(81,204,204)",
        "rgb(142,204,81)",
        "rgb(142,81,204)",
        "rgb(204,173,81)",
        "rgb(81,204,112)",
        "rgb(81,112,204)",
        "rgb(204,81,173)",
        "rgb(204,127,81)",
        "rgb(188,204,81)"
    };

    protected async override Task OnInitializedAsync()
    {
        LineConfig = new LineConfig
        {
            Options = new LineOptions
            {
                Responsive = true,
                MaintainAspectRatio = false,
                Tooltips = new Tooltips
                {
                    Mode = InteractionMode.Nearest,
                    Intersect = true,
                },
                Hover = new Hover
                {
                    Mode = InteractionMode.Nearest,
                    Intersect = true
                },
                Scales = new Scales
                {
                    XAxes = new List<CartesianAxis>
                {
                        new TimeAxis
                        {
                            ScaleLabel = new ScaleLabel
                            {
                                LabelString = "Date",
                            },
                            Time = new TimeOptions
                            {
                                TooltipFormat = "LL"
                            },
                            Ticks = new TimeTicks
                            {
                                FontColor = "#ffffff"
                            },
                            GridLines = new GridLines
                            {
                                Color = "#6c757d"
                            }
                        }
                },
                    YAxes = new List<CartesianAxis>
                {
                        new LinearCartesianAxis
                        {
                            ScaleLabel = new ScaleLabel
                            {
                                LabelString = "Balance"
                            },
                            Ticks = new LinearCartesianTicks
                            {
                                FontColor = "#ffffff",
                                Callback = new JavaScriptHandler<AxisTickCallback>("chartCallbacks.formatCurrencyString")
                            },
                            GridLines = new GridLines
                            {
                                Color = "#6c757d"
                            }
                        }
                }
                },
                Legend = new Legend
                {
                    Labels = new LegendLabels
                    {
                        FontColor = "#ffffff"
                    }
                }
            },
        };

        foreach (Account account in Context.Accounts)
        {
            LineConfig.Data.Datasets.Add(new LineDataset<TimePoint>(account.Balances.Select(balance => new TimePoint(balance.Timestamp.Date, balance.Value)))
            {
                Label = account.Name,
                LineTension = 0,
                Fill = false,
                BorderColor = colors[account.Order % 10]
            });
        }

        await RefreshBalance();
    }

    private async Task ToggleEditMode()
    {
        if (!IsEditing)
        {
            await JSRuntime.InvokeVoidAsync("ChangeElementHeight", AccountCreationContainerReference, 38);
            IsEditing = true;
        }
        else
        {
            await JSRuntime.InvokeVoidAsync("ChangeElementHeight", AccountCreationContainerReference, 0);
            IsEditing = false;
        }
    }

    private async Task CreateAccount()
    {
        if (string.IsNullOrWhiteSpace(NewAccountName) || await Context.FindAsync<Account>(NewAccountName) != null)
        {
            await JSRuntime.InvokeAsync<string>("alert", $"Please enter a valid unique name for the account.");
            return;
        }

        Context.Accounts.Add(new Account
        {
            Name = NewAccountName,
            Order = !Context.Accounts.Any() ? 1 : Context.Accounts.OrderByDescending(account => account.Order).First().Order + 1
        });

        int orderReset = 1;
        foreach (Account account in Context.Accounts.OrderBy(account => account.Order).ToList())
            account.Order = orderReset++;

        await Context.SaveChangesAsync();

        NewAccountName = string.Empty;
    }

    private async Task RefreshBalance()
    {
        NetWorth = Context.Accounts.Sum(account => account.CurrentBalance);
        await InvokeAsync(StateHasChanged);
    }

    private async Task ChangeAccountOrder((string AccountName, bool moveUp) newAccountOrder)
    {
        Account changingAccount = Context.Accounts.Find(newAccountOrder.AccountName);
        int newAccountOrderNumber = newAccountOrder.moveUp ? changingAccount.Order - 1 : changingAccount.Order + 1;
        changingAccount.Order = newAccountOrderNumber;
        ElementReference changingAccountCardReference = AccountCardReferences.First(accountCardReference => accountCardReference.Account.Name == newAccountOrder.AccountName).AccountCardReference;

        Account affectedAccount = Context.Accounts.First(account => account.Order == newAccountOrderNumber);
        if (newAccountOrder.moveUp)
            affectedAccount.Order++;
        else if (!newAccountOrder.moveUp)
            affectedAccount.Order--;
        ElementReference affectedAccountCardReference = AccountCardReferences.First(accountCardReference => accountCardReference.Account.Name == affectedAccount.Name).AccountCardReference;

        await JSRuntime.InvokeVoidAsync("PullAway", changingAccountCardReference);
        await JSRuntime.InvokeVoidAsync("PullAway", affectedAccountCardReference);

        await Context.SaveChangesAsync();
        await InvokeAsync(StateHasChanged);

        await JSRuntime.InvokeVoidAsync("BringBack", changingAccountCardReference);
        await JSRuntime.InvokeVoidAsync("BringBack", affectedAccountCardReference);
    }
}
